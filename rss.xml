<?xml version="1.0" encoding="ISO-8859-1"?>
<rss version="2.0">
<channel>
<title>Harvesting Clouds</title>
<link>http://HarvestingClouds.com</link>
<description>Blog about all things regarding private and public clouds</description>
<language>en-us</language>
<item>
<title>Step by Step Azure Resource Manager (ARM) Templates - Index</title>
<description><![CDATA[<p><strong>Azure Resource Manager (ARM) Template</strong> is a JavaScript Object Notation (JSON) file that defines one or more resources to deploy to a resource group. It also defines the dependencies between the deployed resources. The template can be used to deploy the resources consistently and repeatedly.</p>
<p>ARM Templates can be used for the deployment of resources on both Azure and Azure Stack. Using these templates for all deployments provides you with various <strong>benefits</strong> including:</p>
<ul>
<li><strong>Declarative Deployment</strong> – All you need to do is declare what you need to deploy. You don't need to create any complex rules or write lengthy scripts.</li>
<li><strong>Idempotency</strong> – You can deploy the same template over and over again without affecting the current resources.</li>
<li><strong>Predictability</strong> - Using Templates you can have accurate predictability when performing large deployments. You reduce any manual errors.</li>
<li><strong>Repitition without Errors</strong> - You can deploy the same infrastructure over and over again (e.g. in Dev-test environments and then in production).</li>
</ul>
<p>This series of posts try to decode and understand the ARM Templates &quot;Step By Step&quot;.</p>
<p>This post is an index of all the posts, in sequence, for understanding the Azure Resource Manager (ARM) Templates. This post will be updated regularly as more posts on this topic are added.</p>
<ol>
<li><a href="#">Index</a> </li>
<li><a href="/post/step-by-step-arm-templates-json-101-for-it-administrators/">JSON 101 for IT Administrators</a></li>
<li><a href="/post/step-by-step-arm-templates-what-is-in-an-arm-template-understanding-all-components/">What is in an ARM Template - Understanding All Components</a></li>
<li><a href="/post/step-by-step-arm-templates-what-is-in-an-arm-template-understanding-components-2-parameters/">What is in an ARM Template - Understanding Components 2 - Parameters</a></li>
<li><a href="/post/step-by-step-arm-templates-what-is-in-an-arm-template-understanding-components-3-variables/">What is in an ARM Template - Understanding Components 3 - Variables</a></li>
<li><a href="/post/step-by-step-arm-templates-what-is-in-an-arm-template-understanding-components-4-resources/">What is in an ARM Template - Understanding Components 4 - Resources</a></li>
<li><a href="/post/step-by-step-arm-templates-what-is-in-an-arm-template-understanding-components-5-outputs/">What is in an ARM Template - Understanding Components 5 - Outputs</a></li>
<li><a href="/post/step-by-step-arm-templates-helper-functions/">Helper Functions in ARM Templates</a></li>
<li><a href="/post/step-by-step-arm-templates-building-your-first-arm-template/">Building your first ARM Template</a></li>
<li><a href="/post/step-by-step-arm-templates-deploying-template-using-azure-portal/">Deploying Template Using Azure Portal</a></li>
</ol>]]></description>
<link>http://HarvestingClouds.com/post/step-by-step-azure-resource-manager-arm-templates-index</link>
<pubDate>Fri, 30 Sep 2016 00:00:00 +0500</pubDate>
</item>
<item>
<title>Step by Step ARM Templates - Creating Parameters file for an ARM Template</title>
<description><![CDATA[<p>You can pass the input values for the Parameters in your ARM template using an additional JSON file. This additional file is what we will be referring to as <strong>Parameters File</strong>.</p>
<p>The only restriction on a parameters file is that the size of the parameter file cannot be more than 64 KB.</p>
<p>Parameters file follows a similar structure to the ARM Template. They are very simple as compared to the ARM template. In all they have 3 sections as explained below:</p>
<ol>
<li><strong>$schema</strong> - Required Object - Location of the JSON schema file that describes the version of the template language.</li>
<li><strong>contentVersion</strong> - Required Object - Version of the template (such as 1.2.0.20). When deploying resources using the template, this value can be used to make sure that the right template is being used.</li>
<li><strong>parameters</strong> - Required Object - This is a JSON object which contains various objects as it's members. Each object within the &quot;parameters&quot; object represent a value for a parameter corresponding to your ARM template.</li>
</ol>
<p>Let's check how the parameters file will look like for the ARM template we have built earlier for deploying Storage Account and a Virtual Network.</p>
<pre><code>{
    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json#",
    "contentVersion": "1.0.0.0",
    "parameters": {
        "vhdStorageName": {
            "value": "harvestingstorage101"
        },
        "virtualNetworkName": {
            "value": "testvNet101"
        }
    }
}</code></pre>
<p>Note that the only 2 parameter values are provided. These correspond to the parameters in the ARM template. </p>
<p><strong>Note:</strong> The parameter names should match to the parameters defined in the ARM template.</p>]]></description>
<link>http://HarvestingClouds.com/post/step-by-step-arm-templates-creating-parameters-file-for-an-arm-template</link>
<pubDate>Wed, 14 Sep 2016 00:00:00 +0500</pubDate>
</item>
<item>
<title>Step by Step ARM Templates - Deploying Template Using Azure PowerShell</title>
<description><![CDATA[<p>In the previous blog you learned <a href="/post/step-by-step-arm-templates-building-your-first-arm-template/">How to build your first ARM Template</a> . Now that you have a fully functional ARM template we want to deploy this template to Azure.</p>
<p>There are various options to deploy a template to Azure. We already saw in the last blog <a href="/post/step-by-step-arm-templates-deploying-template-using-azure-portal/">How to deploy template using <strong>Azure Portal</strong></a>. Now we will look at <strong>Azure PowerShell</strong> as more programmatic and automated way to deploy the template.</p>
<h2>Pre-requisites</h2>
<p>Things you should know before deployment</p>
<ol>
<li><strong>Azure PowerShell</strong> - This should be installed on the machine from where the Steps will be followed. If you don't have this then use this link to get it: <a href="https://azure.microsoft.com/en-us/documentation/articles/powershell-install-configure/">Get Azure PowerShell</a></li>
<li><strong>Azure Subscription</strong> - where you want to deploy your template</li>
<li><strong>Resource Group</strong> - This is the resource group in Azure where you will be deploying your template. You can create a new resource group (for the resources that will be deployed by the template) or use an existing one.</li>
<li><strong>Parameters</strong> - Value of the input parameters to the template should be known to you for the deployment. Follow all your naming conventions when defining the parameters for deployments of resources in Azure. </li>
<li><strong>Internet Connectivity</strong> - This should be present on the machine from where the Steps will be followed for connectivity to Azure</li>
</ol>
<h2>Steps for Deployment</h2>
<ol>
<li>First, launch a PowerShell window as an Administrator</li>
<li>Then, log into the Azure account. </li>
</ol>
<p>Run the below cmdlet to log into Azure:</p>
<pre><code>Add-AzureRmAccount</code></pre>
<ol>
<li>Select appropriate Azure Subscription</li>
</ol>
<p>You have two choices here. You can either use below cmdlet to use Subscription ID</p>
<pre><code>Set-AzureRmContext -SubscriptionID &lt;YourSubscriptionId&gt;</code></pre>
<p>Or you can use the Subscription name with the below cmdlet:</p>
<pre><code>Select-AzureRmSubscription -SubscriptionName "&lt;Your Subscription Name&gt;"</code></pre>
<ol>
<li>Next, if you already have a resource group to which you want to deploy the template then skip this step. Else create a new resource group. A resource in Azure ARM architecture can only exist in a resource group. </li>
</ol>
<p>Use below cmdlet to create a new Resource Group:</p>
<pre><code>New-AzureRmResourceGroup -Name TestResourceGroup01 -Location "Central US"</code></pre>
<ol>
<li>Before deploying the Resource Template to Azure, you should Test it. This step is optional but highly recommended.</li>
</ol>
<p>Use the below cmdlet to test and validate your template:</p>
<pre><code>Test-AzureRmResourceGroupDeployment -ResourceGroupName TestResourceGroup01 -TemplateFile &lt;PathToJsonTemplate&gt;</code></pre>
<ol>
<li>Now comes the last step i.e. to deploy the template. You have two options when deploying the template. You can either deploy a template without any parameters (if none are required) or you need to specify the parameters. Let's check both these options next.</li>
</ol>
<h3>Deploying Template which doesn't need Parameters</h3>
<p>You can deploy such template using <code>New-AzureRmResourceGroupDeployment</code> cmdlet.
If the template file is on a local directory then use the below cmdlet:</p>
<pre><code>New-AzureRmResourceGroupDeployment -Name ExampleDeployment -ResourceGroupName TestResourceGroup01 -TemplateFile &lt;PathToTemplate&gt;</code></pre>
<p>If the template file is uploaded to some hosted location and is accessible via a link, then use the below cmdlet to deploy the template:</p>
<pre><code>New-AzureRmResourceGroupDeployment -Name ExampleDeployment -ResourceGroupName TestResourceGroup01 -TemplateUri &lt;LinkToTemplate&gt;</code></pre>
<h3>Deploying Template with Parameters</h3>
<p>Deploying of the template is exactly similar as the previous section. You use the same cmdlet. To specify the parameter, you have 4 options. Use the below cmdlets for the option you want to use.</p>
<p><strong>Option 1</strong> - Using Inline Parameter</p>
<pre><code>New-AzureRmResourceGroupDeployment -Name ExampleDeployment -ResourceGroupName TestResourceGroup01 -TemplateFile &lt;PathToTemplate&gt; -myParameterName "parameterValue" -secondParameterName "secondParameterValue"</code></pre>
<p><strong>Option 2</strong> - Using Parameter Object</p>
<pre><code>$parameters = @{"&lt;ParameterName&gt;"="&lt;Parameter Value&gt;"}
New-AzureRmResourceGroupDeployment -Name ExampleDeployment -ResourceGroupName TestResourceGroup01 -TemplateFile &lt;PathToTemplate&gt; -TemplateParameterObject $parameters</code></pre>
<p><strong>Option 3</strong> - Using Parameter file which is in local environment</p>
<pre><code>New-AzureRmResourceGroupDeployment -Name ExampleDeployment -ResourceGroupName TestResourceGroup01 -TemplateFile &lt;PathToTemplate&gt; -TemplateParameterFile &lt;PathToParameterFile&gt;</code></pre>
<p><strong>Option 4</strong> - Using Parameter file which is located externally and can be referenced via Link</p>
<pre><code>New-AzureRmResourceGroupDeployment -Name ExampleDeployment -ResourceGroupName TestResourceGroup01 -TemplateUri &lt;LinkToTemplate&gt; -TemplateParameterUri &lt;LinkToParameterFile&gt;</code></pre>
<h3>Key Gotchas</h3>
<ol>
<li>If you provide values for a parameter in both the local parameter file and inline, the inline value takes precedence.</li>
<li>You cannot use inline parameters with an external parameter file. All inline parameters are ignored when you specify &quot;TemplateParameterUri&quot; parameter.</li>
<li>As a best practice, do not store sensitive infomation in the parameters file e.g. Local admin password. Instead either provide these dynamically using inline parameters. Or store them using the Azure Key vault and then reference the key vault in your parameters file.</li>
</ol>
<p>You can find more details about these cmdlets here: <a href="https://azure.microsoft.com/en-us/documentation/articles/resource-group-template-deploy/#deploy-with-powershell">Deploy resources with Resource Manager templates and Azure PowerShell</a></p>
<p>In the next blog, we will see how to create a Parameters File for providing parameters dynamically to the template.</p>]]></description>
<link>http://HarvestingClouds.com/post/step-by-step-arm-templates-deploying-template-using-azure-powershell</link>
<pubDate>Sun, 11 Sep 2016 00:00:00 +0500</pubDate>
</item>
<item>
<title>Step by Step ARM Templates - Deploying Template Using Azure Portal</title>
<description><![CDATA[<p>In the last blog you learned <a href="/post/step-by-step-arm-templates-building-your-first-arm-template/">How to build your first ARM Template</a> . Now that you have a fully functional ARM template we want to deploy this template to Azure.</p>
<p>There are various options to deploy a template to Azure. Using Azure portal is by far the easiest and most intuitive option for the deployment. Follow the steps in this blog to deploy your template to Azure.</p>
<h2>Pre-requisites</h2>
<p>Things you should know before deployment</p>
<ol>
<li><strong>Azure Subscription</strong> - where you want to deploy your template</li>
<li><strong>Resource Group</strong> - This is the resource group in Azure where you will be deploying your template. You can create a new resource group (for the resources that will be deployed by the template) or use an existing one.</li>
<li><strong>Parameters</strong> - Value of the input parameters to the template should be known to you for the deployment. Follow all your naming conventions when defining the parameters for deployments of resources in Azure.</li>
</ol>
<h2>Steps for Deployment</h2>
<ol>
<li>First, log into the Azure Portal.</li>
<li>
<p>Next, go to &quot;New&quot; and type &quot;Template deployment&quot; in the search box and hit enter.</p>
<p><img src="/images/147559616157f3cf81381da.png" alt="New Deployment" /></p>
</li>
<li>
<p>Next, click on the <strong>Template Deployment</strong> and then click on &quot;Create&quot;</p>
<p><img src="/images/147559654057f3d0fc1bf5c.png" alt="Create Deployment" /></p>
</li>
<li>
<p>Now click on the &quot;<strong>Template (Edit Template)</strong>&quot;. It will open a panel to paste your template. Delete whatever is auto populated in the template area. Copy your whole json template and paste it here. Note that the left section in the new panel will update to show you what parameters, variables, and resources you have in the template. Click on &quot;Save&quot; once done.</p>
<p><img src="/images/147559697957f3d2b32ff67.png" alt="Editing Template" /></p>
</li>
<li>
<p>Next, click on the &quot;<strong>Parameters (Edit Parameters)</strong>&quot; on the left side. The parameters will be automatically picked from the template. The parameters for which the default value is provided will be automatically populated. Rest you will have to provide the inputs. Click Ok once done.</p>
<p><img src="/images/147559719657f3d38c652e3.png" alt="Providing Parameters" /></p>
</li>
<li>
<p>Next, you have the option to select the <strong>Resource Group</strong>. You can either create a new resource group (for all the resources that will be deployed via the template) or you can use and existing resource group.</p>
<p><img src="/images/147559727457f3d3da45879.png" alt="Resource Group Selection" /></p>
</li>
<li>
<p>The last option is to click on the &quot;<strong>Legal Terms</strong>&quot; and read through the terms. If you agree then click on the &quot;Purchase&quot; button. </p>
<p><img src="/images/147559762057f3d534eae90.png" alt="Legal Terms" /></p>
</li>
<li>Finally, click on the <strong>Create</strong> to submit the deployment. </li>
</ol>
<p>You can monitor the job performing the deployments and progress of the same. After some time the deployment will finish successfully and you can view the resources in the resource group you selected.</p>]]></description>
<link>http://HarvestingClouds.com/post/step-by-step-arm-templates-deploying-template-using-azure-portal</link>
<pubDate>Thu, 08 Sep 2016 00:00:00 +0500</pubDate>
</item>
<item>
<title>Step by Step ARM Templates - Building your first ARM Template</title>
<description><![CDATA[<p>In this blog post, we will use the knowledge learned in previous blogs and will build a basic ARM template.
If you haven't checked previous blog posts then have a quick read of your preferred topics here: <a href="/post/step-by-step-azure-resource-manager-arm-templates-index/">Step by Step Azure Resource Manager (ARM) Templates - Index</a></p>
<p>To follow this blog, you can use any text editor which can provide JSON syntax highlighting. We will be looking at using Visual Studio to author ARM templates in a future blog post. Visual Studio can provide JSON outlining and is a very powerful tool for authoring ARM templates.</p>
<p>Let us assume that you want to deploy a storage account and build a virtual network in Azure. You want to automate the process and need to repeat the process in various environments. ARM templates fit the bill for the solution of this problem.</p>
<p>In the next few sections, we will build each section of the template and then at the end will check the complete template.</p>
<h3>1. Template Header</h3>
<p>This section is very basic and contains just the schema and the content version. You can use the content version to manage the development versions of the template as you make changes to your templates in the future.</p>
<pre><code>"$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
"contentVersion": "1.0.0.0",</code></pre>
<h3>2. Parameters</h3>
<p>Here we define all the inputs we need from the end users. We provide default values for those parameters for which we know what the most common values will be based on our environment. For the current template we define two parameters:</p>
<ul>
<li><strong>vhdStorageName</strong> - This is the name of the storage account in Azure which will be created by the deployment of this template.</li>
<li><strong>virtualNetworkName</strong> - This is the name of the Virtual Network which will be created by the deployment of this template.</li>
</ul>
<p>As a best practice, provide the metadata, describing what each parameter is for. Also, note that we have used pascal casing to name the parameters with very descriptive names.</p>
<pre><code>"parameters": {
    "vhdStorageName": {
        "type": "string",
        "minLength": 1,
        "defaultValue": "mystorage101",
        "metadata": {
            "description": "Name of the Storage Account."
        }
    },
    "virtualNetworkName": {
        "type": "string",
        "metadata": {
            "description": "Name of the virtual network."
        }
    }
},</code></pre>
<h3>3. Variables</h3>
<p>Next, we add some variables for the values which will be reused later in the template in the resources section. We create variables for all those reusable values for which we know what their value at deployment will be. We define 4 variables in this template:</p>
<ul>
<li><strong>addressPrefix</strong> - Address prefix for the Virtual Network </li>
<li><strong>subnetName</strong> - Subnet name which will be created under the virtual network</li>
<li><strong>subnetPrefix</strong> - Subnet prefix for the subnet, which will be created under the virtual network</li>
<li><strong>vhdStorageType</strong> - Type of the storage account. Here we used Standard locally redundant storage (LRS)</li>
</ul>
<p>Variables section look as below:</p>
<pre><code>"variables": {
    "addressPrefix": "10.0.0.0/16",
    "subnetName": "Subnet",
    "subnetPrefix": "10.0.0.0/24",
    "vhdStorageType": "Standard_LRS"
},</code></pre>
<h3>4. Resources</h3>
<p>Now comes the last and main section i.e. Resources. Here we define both the resources for our template:</p>
<ul>
<li>Storage Account</li>
<li>Virtual Network</li>
</ul>
<p>Let us look at each of these resources one by one.</p>
<p><strong>A. Storage Account Resource</strong></p>
<p>This resource has below properties (or key-value pairs):</p>
<ol>
<li><strong>Type</strong> - Type of the resource is set to Microsoft.Storage/storageAccounts. This is what tells the Azure that the current resource is a Storage Account</li>
<li><strong>Name</strong> - This defines the name of the storage account to be deployed based on the parameter to the template</li>
<li><strong>API Version</strong> - this is the standard version for the REST API in Azure</li>
<li><strong>Location</strong> - This is the Azure location. The location is found dynamically based on the location of the resource group to which this template will be deployed.</li>
<li><strong>tags</strong> - only one tag is defined for the display name. You should have more tags in case of a production ready template</li>
<li><strong>properties</strong> - This is where you tell Azure what kind of storage account you need. Here the account type is set using the value of the variable vhdStorageType.</li>
</ol>
<p><strong>B. Virtual Network Resource</strong></p>
<p>This resource has below properties (or key-value pairs):</p>
<ol>
<li><strong>Type</strong> - Type of the resource is set to Microsoft.Network/virtualNetworks. This is what tells the Azure that the current resource is a Virtual Network</li>
<li><strong>Name</strong> - This defines the name of the virtual network to be deployed based on the parameter to the template</li>
<li><strong>API Version</strong> - this is the standard version for the REST API in Azure</li>
<li><strong>Location</strong> - This is the Azure location. The location is found dynamically based on the location of the resource group to which this template will be deployed.</li>
<li><strong>tags</strong> - only one tag is defined for the display name. You should have more tags in case of a production ready template</li>
<li><strong>properties</strong> - This is where you define the address space for the virtual network. You also define the subnet under the virtual network here.</li>
</ol>
<p>The resources section look like below:</p>
<pre><code>"resources": [
    {
        "type": "Microsoft.Storage/storageAccounts",
        "name": "[parameters('vhdStorageName')]",
        "apiVersion": "2015-06-15",
        "location": "[resourceGroup().location]",
        "tags": {
            "displayName": "StorageAccount"
        },
        "properties": {
            "accountType": "[variables('vhdStorageType')]"
        }
    },
    {
        "apiVersion": "2015-06-15",
        "type": "Microsoft.Network/virtualNetworks",
        "name": "[parameters('virtualNetworkName')]",
        "location": "[resourceGroup().location]",
        "tags": {
            "displayName": "VirtualNetwork"
        },
        "properties": {
            "addressSpace": {
                "addressPrefixes": [
                    "[variables('addressPrefix')]"
                ]
            },
            "subnets": [
                {
                    "name": "[variables('subnetName')]",
                    "properties": {
                        "addressPrefix": "[variables('subnetPrefix')]"
                    }
                }
            ]
        }
    }
]</code></pre>
<h3>Complete Template</h3>
<p>Here is the complete template build from all the sections discussed above. You can copy and use this template for testing and working along with next deployment posts.</p>
<pre><code>{
    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
    "contentVersion": "1.0.0.0",
    "parameters": {
        "vhdStorageName": {
            "type": "string",
            "minLength": 1,
            "defaultValue": "mystorage101",
            "metadata": {
                "description": "Name of the Storage Account."
            }
        },
        "virtualNetworkName": {
            "type": "string",
            "metadata": {
                "description": "Name of the virtual network."
            }
        }
    },
    "variables": {
        "addressPrefix": "10.0.0.0/16",
        "subnetName": "Subnet",
        "subnetPrefix": "10.0.0.0/24",
        "vhdStorageType": "Standard_LRS"
    },
    "resources": [
        {
            "type": "Microsoft.Storage/storageAccounts",
            "name": "[parameters('vhdStorageName')]",
            "apiVersion": "2015-06-15",
            "location": "[resourceGroup().location]",
            "tags": {
                "displayName": "StorageAccount"
            },
            "properties": {
                "accountType": "[variables('vhdStorageType')]"
            }
        },
        {
            "apiVersion": "2015-06-15",
            "type": "Microsoft.Network/virtualNetworks",
            "name": "[parameters('virtualNetworkName')]",
            "location": "[resourceGroup().location]",
            "tags": {
                "displayName": "VirtualNetwork"
            },
            "properties": {
                "addressSpace": {
                    "addressPrefixes": [
                        "[variables('addressPrefix')]"
                    ]
                },
                "subnets": [
                    {
                        "name": "[variables('subnetName')]",
                        "properties": {
                            "addressPrefix": "[variables('subnetPrefix')]"
                        }
                    }
                ]
            }
        }
    ]
}</code></pre>
<p>In the next blog, we will learn how to deploy this template.</p>]]></description>
<link>http://HarvestingClouds.com/post/step-by-step-arm-templates-building-your-first-arm-template</link>
<pubDate>Sun, 04 Sep 2016 00:00:00 +0500</pubDate>
</item>
<item>
<title>Step by Step ARM Templates - Helper Functions</title>
<description><![CDATA[<p>ARM Templates has various dynamic constructs called <strong>Helper Functions</strong> which can make your template more generic. These constructs reduce the hard coded values in your templates. You can use the information from this blog to make your existing templates more dynamic and start writing new templates with a much generic approach.</p>
<p>Let's look at the most important helper functions and their practical usage one by one. </p>
<h3>1. Resource Id - Resource Function</h3>
<p>You use this function to determine the ID of a resource. This is only used when the resource (whose ID is needed) is not being deployed in the current template and it already exists in Azure.</p>
<p>The generic syntax to use this is:</p>
<pre><code>resourceId ([subscriptionId], [resourceGroupName], resourceType, resourceName1, [resourceName2]...)</code></pre>
<p>Only required parameters of this helper function are resourceType and resourceName1.</p>
<p>These parameters are as follows:</p>
<ul>
<li>subscription ID - This is only needed if you want to refer a different subscription. Default value is the current subscription</li>
<li>resource Group Name - Name of the resource group where the resource exists. Default is the current resource group, in which you are deploying the template</li>
<li>resource Type - Type of resource including resource provider namespace</li>
<li>resource Name 1  - Name of the resource</li>
<li>resource Name 2  - Next resource name segment if resource is nested. E.g. a VM Extension</li>
</ul>
<p><strong>Example</strong></p>
<pre><code>"vnetId1": "[resourceId('AE06-Mgmt-RG','Microsoft.Network/virtualNetworks', parameters('virtualNetworkName'))]",
"vnetId2": "[resourceId('Microsoft.Network/virtualNetworks', variables('virtualNetworkName'))]"</code></pre>
<p>The above example shows two ways of using the resource ID helper function to determine the Id of a virtual network. First one uses the resource group, resource type and resource name. Second example uses only the resource Type and resource name. Second example assumes the resource group to be same as the template being deployed to.</p>
<h3>2. Resource Group - Resource Function</h3>
<p>This helper function returns an object that represents the current resource group to which the template is being deployed.</p>
<p>The generic syntax to use this is:</p>
<pre><code>resourceGroup()</code></pre>
<p>No parameters are needed in this helper function.</p>
<p><strong>Example</strong></p>
<pre><code>"vhdStorageName": "[concat('vhdstorage', uniqueString(resourceGroup().id))]",
 "storageAccountResourceGroup": "[resourcegroup().name]",
 "location": "[resourceGroup().location]"</code></pre>
<p>The above example shows 3 uses of the resource group helper functions. First one uses the ID of the resource group, second uses the name property and third uses the location for the current resource group.</p>
<h3>3. Subscription - Resource Function</h3>
<p>The generic syntax to use this is:</p>
<pre><code>subscription()</code></pre>
<p>No parameters are needed in this helper function.</p>
<p><strong>Example</strong></p>
<pre><code>"subscriptionId": "[subscription().subscriptionId]"</code></pre>
<p>The above example is straightforward. It fetches the subscription Id of the current subscription.</p>
<h3>4. Concat - String Function</h3>
<p>This function is used to concatinate (i.e. combine) two or more values.</p>
<p>The generic syntax to use this is:</p>
<pre><code>concat (array1, array2, array3, ...)</code></pre>
<p>At least 1 array is needed for concat to work. </p>
<p><strong>Example</strong></p>
<pre><code>"subnetRef": "[concat(variables('vNetId'), '/subnets/', variables('subnetName'))]"</code></pre>
<p>The above example combines (or concatinates) 3 text values. First value is the value of variable vNetId. Second value is a string &quot;/subnets/&quot;. Third value is the value of the variable subnet Name.</p>
<p>These are the most common Helper functions that you will use in 80%-90% of the templates. </p>
<p>To check the complete list of Helper Functions, check this official link: <a href="https://azure.microsoft.com/en-us/documentation/articles/resource-group-template-functions/#resource-functions">Azure Resource Manager template functions</a></p>]]></description>
<link>http://HarvestingClouds.com/post/step-by-step-arm-templates-helper-functions</link>
<pubDate>Wed, 31 Aug 2016 00:00:00 +0500</pubDate>
</item>
<item>
<title>Step by Step ARM Templates - What is in an ARM Template - Understanding Components 5 - Outputs</title>
<description><![CDATA[<p>If you haven't checked the previous blog on the overall structure of the ARM template, I suggest you give it a quick read before checking the component described in this post in detail.</p>
<ol>
<li><a href="../step-by-step-arm-templates-what-is-in-an-arm-template-understanding-all-components/">Understanding all components</a></li>
<li><a href="../step-by-step-arm-templates-what-is-in-an-arm-template-understanding-components-2-parameters/">Parameters</a></li>
<li><a href="../step-by-step-arm-templates-what-is-in-an-arm-template-understanding-components-3-variables/">Variables</a></li>
<li><a href="../step-by-step-arm-templates-what-is-in-an-arm-template-understanding-components-4-resources/">Resources</a></li>
<li><a href="../step-by-step-arm-templates-what-is-in-an-arm-template-understanding-components-5-outputs/">Outputs - This blog post</a></li>
</ol>
<h2>Outputs</h2>
<p>This section is used to output any values after the deployment of the ARM Template. This can output any Ids or connection strings based on the deployed resources. </p>
<p>This is a single JSON object with various output objects (just like Parameters. The overall JSON structure looks like below:</p>
<pre><code>"outputs": { 
    "output1" : {
                     "type":"string",
                     "value": "value1"
      },
    "output2" : {
                     "type":"string",
                     "value": "value2"
      },
}</code></pre>
<p>Each output object has 2 properties:</p>
<ol>
<li>Type - Data type of the output</li>
<li>Value - value of the output</li>
</ol>
<p>A real life example with look like below:</p>
<pre><code>"outputs": {
    "adminUsername": {
        "type": "string",
        "value": "[parameters('adminUsername')]"
    }
}</code></pre>
<p>The above example will output the administrator Username using the parameter from the template.</p>
<p>That's all there is to Outputs in ARM Templates. If you have any doubts, please comment in the below section. Use the links at the Top to know all about other components in an ARM Template.</p>]]></description>
<link>http://HarvestingClouds.com/post/step-by-step-arm-templates-what-is-in-an-arm-template-understanding-components-5-outputs</link>
<pubDate>Tue, 30 Aug 2016 00:00:00 +0500</pubDate>
</item>
<item>
<title>Step by Step ARM Templates - What is in an ARM Template - Understanding Components 4 - Resources</title>
<description><![CDATA[<p>If you haven't checked the previous blog on the overall structure of the ARM template, I suggest you give it a quick read before checking the component described in this post in detail.</p>
<ol>
<li><a href="../step-by-step-arm-templates-what-is-in-an-arm-template-understanding-all-components/">Understanding all components</a></li>
<li><a href="../step-by-step-arm-templates-what-is-in-an-arm-template-understanding-components-2-parameters/">Parameters</a></li>
<li><a href="../step-by-step-arm-templates-what-is-in-an-arm-template-understanding-components-3-variables/">Variables</a></li>
<li><a href="../step-by-step-arm-templates-what-is-in-an-arm-template-understanding-components-4-resources/">Resources  - This blog post</a></li>
<li><a href="../step-by-step-arm-templates-what-is-in-an-arm-template-understanding-components-5-outputs/">Outputs</a></li>
</ol>
<h2>Resources</h2>
<p>This is the major section of the whole ARM template. This is where you define what resources should be deployed in Azure. You also define dependencies between resources in this section. </p>
<p>The resources section consist of an array of JSON Objects as shown below:</p>
<pre><code>"resources": [
        { },
        { },
]</code></pre>
<p>Each object in the array (represented via curly braces) is an Azure resource. You can deploy multiple resources in a single ARM template. E.g. You can deploy a new Storage Account, new Virtual Network and three Virtual Machines in that virtual network within a single template.
Within the object, various properties (and nested properties) are used to provide the configurations of each resource. </p>
<h3>Elements</h3>
<p>Different elements in a single resource object can be one of the following:</p>
<ol>
<li><strong>apiVersion</strong> - <strong><em>Required</em></strong> - Version of the API. e.g. &quot;2015-06-15&quot;</li>
<li><strong>type</strong> - <strong><em>Required</em></strong> - Type of the resource. This value is a combination of the namespace of the resource provider and the resource type that the resource provider supports. e.g. Azure Storage Account will have type as &quot;Microsoft.Storage/storageAccounts&quot;.</li>
<li><strong>name</strong> - <strong><em>Required</em></strong> - Name of the resource. The name must follow URI component restrictions and also the Azure naming restrictions if any. E.g. Storage account name can only be in small letters and has to be unique.</li>
<li><strong>location</strong> - Optional - Use supported geo-locations of the provided resource without any spaces. Or use the resource group's location dynamically.</li>
<li><strong>tags</strong> - Optional - Tags that are associated with the resource.</li>
<li><strong>dependsOn</strong> - Optional - Other resources in the same template, that the current resource being defined depends on. The dependencies between resources are evaluated and resources are deployed in their dependent order. When resources are not dependent on each other, they are attempted to be deployed in parallel. The value can be a comma-separated list of resource names or resource unique identifiers.</li>
<li><strong>properties</strong> - Optional - Resource specific configuration settings. E.g. Account type property for a storage account name.</li>
<li><strong>resources</strong> - Optional - Child resources that depend on the resource being defined. E.g. Extension resources for a Virtual Machine resource.</li>
</ol>
<h3>Examples</h3>
<p>Let's look at two examples. First, we will take a simple resource example to deploy a storage account in Azure:</p>
<pre><code>{
            "type": "Microsoft.Storage/storageAccounts",
            "name": "[variables('vhdStorageName')]",
            "apiVersion": "2015-06-15",
            "location": "[resourceGroup().location]",
            "tags": {
                "displayName": "StorageAccount",
                "department" : "Finance",
                "application" : "database"
            },
            "properties": {
                "accountType": "[variables('vhdStorageType')]"
            }
        }</code></pre>
<p>Above example will deploy a storage account with the name from &quot;vhdStorageName&quot; variable. It will apply 3 tags to the resource after deployment. It will use the account type (i.e. standard or premium) based on the value of the &quot;vhdStorageType&quot; variable. If you want to deploy 2 or more similar storage accounts, then just copy and paste the json for the resource, separated by comma. It will become another object in the Resources array.</p>
<p>Now let's look at a complex and larger example of deploying a single virtual machine with one extension for Diagnostics.</p>
<pre><code>    {
        "apiVersion": "2015-06-15",
        "type": "Microsoft.Compute/virtualMachines",
        "name": "[variables('vmName')]",
        "location": "[resourceGroup().location]",
        "tags": {
            "displayName": "VirtualMachine"
        },
        "dependsOn": [
            "[concat('Microsoft.Storage/storageAccounts/', variables('vhdStorageName'))]",
            "[concat('Microsoft.Network/networkInterfaces/', variables('nicName'))]"
        ],
        "properties": {
            "hardwareProfile": {
                "vmSize": "[variables('vmSize')]"
            },
            "osProfile": {
                "computerName": "[variables('vmName')]",
                "adminUsername": "[parameters('adminUsername')]",
                "adminPassword": "[parameters('adminPassword')]"
            },
            "storageProfile": {
                "imageReference": {
                    "publisher": "[variables('imagePublisher')]",
                    "offer": "[variables('imageOffer')]",
                    "sku": "[parameters('windowsOSVersion')]",
                    "version": "latest"
                },
                "osDisk": {
                    "name": "osdisk",
                    "vhd": {
                        "uri": "[concat('http://', variables('vhdStorageName'), '.blob.core.windows.net/', variables('vhdStorageContainerName'), '/', variables('OSDiskName'), '.vhd')]"
                    },
                    "caching": "ReadWrite",
                    "createOption": "FromImage"
                }
            },
            "networkProfile": {
                "networkInterfaces": [
                    {
                        "id": "[resourceId('Microsoft.Network/networkInterfaces', variables('nicName'))]"
                    }
                ]
            },
            "diagnosticsProfile": {
                "bootDiagnostics": {
                    "enabled": true,
                    "storageUri": "[concat('http://', variables('diagnosticsStorageAccountName'), '.blob.core.windows.net')]"
                }
            }
        },
        "resources": [
            {
                "type": "extensions",
                "name": "Microsoft.Insights.VMDiagnosticsSettings",
                "apiVersion": "2015-06-15",
                "location": "[resourceGroup().location]",
                "tags": {
                    "displayName": "AzureDiagnostics"
                },
                "dependsOn": [
                    "[concat('Microsoft.Compute/virtualMachines/', variables('vmName'))]"
                ],
                "properties": {
                    "publisher": "Microsoft.Azure.Diagnostics",
                    "type": "IaaSDiagnostics",
                    "typeHandlerVersion": "1.5",
                    "autoUpgradeMinorVersion": true,
                    "settings": {
                        "xmlCfg": "[base64(concat(variables('wadcfgxstart'), variables('wadmetricsresourceid'), variables('wadcfgxend')))]",
                        "storageAccount": "[variables('diagnosticsStorageAccountName')]"
                    },
                    "protectedSettings": {
                        "storageAccountName": "[variables('diagnosticsStorageAccountName')]",
                        "storageAccountKey": "[listkeys(variables('accountid'), '2015-06-15').key1]",
                        "storageAccountEndPoint": "https://core.windows.net"
                    }
                }
            }
        ]
    }</code></pre>
<p>Note that the above code snippet defines a single virtual machine. Let us decode various sections of this complex resource:</p>
<ul>
<li>It begins with simple properties like apiVersion, type, name, location and tags as discussed in the previous example. These are straightforward and thus values are provided to these attributes.</li>
<li>Next is the <strong>dependsOn</strong> section. This defines the dependency between resources. In the above example, the virtual machine resource is dependent on the storage account and a network interface, which are also defined in the template. These 2 resources will be created before the virtual machine creation/deployment. If these resources are not created in the template then it will check for the presence of these resources in the current subscription. If they are not present the template will not get deployed and will error out.</li>
<li>Next are various <strong>properties</strong> to configure the Virtual machine, like hardware profile, os profile, storage profile, os disk, network profile, diagnostics profile etc.</li>
<li>Next, we have additional <strong>sub-resources</strong>. These are Azure resources which will be created and linked to the current resource. Only one sub-resource is created in the above example which is an extension for VM diagnostics settings.</li>
</ul>
<p>That's all there is to Resources in ARM Templates. If you have any doubts, please comment in the below section. Use the links at the Top to know all about other components in an ARM Template.</p>]]></description>
<link>http://HarvestingClouds.com/post/step-by-step-arm-templates-what-is-in-an-arm-template-understanding-components-4-resources</link>
<pubDate>Mon, 29 Aug 2016 00:00:00 +0500</pubDate>
</item>
<item>
<title>Step by Step ARM Templates - What is in an ARM Template - Understanding Components 3 - Variables</title>
<description><![CDATA[<p>If you haven't checked the previous blog on the overall structure of the ARM template, I suggest you give it a quick read before checking the component described in this post in detail.</p>
<ol>
<li><a href="../step-by-step-arm-templates-what-is-in-an-arm-template-understanding-all-components/">Understanding all components</a></li>
<li><a href="../step-by-step-arm-templates-what-is-in-an-arm-template-understanding-components-2-parameters/">Parameters</a></li>
<li><a href="../step-by-step-arm-templates-what-is-in-an-arm-template-understanding-components-3-variables/">Variables - This blog post</a></li>
<li><a href="../step-by-step-arm-templates-what-is-in-an-arm-template-understanding-components-4-resources/">Resources</a></li>
<li><a href="../step-by-step-arm-templates-what-is-in-an-arm-template-understanding-components-5-outputs/">Outputs</a></li>
</ol>
<h2>Variables</h2>
<p>Variables are values that you either know beforehand or you can construct from the input parameters. These variables can then be reused at multiple locations in the resources section. If you later want to change the value of a variable then it automatically gets updated at all other locations. They can be used to define a resource property.</p>
<h3>Defining Variables</h3>
<p>Variable is a one huge JSON object. Each property can be one of the simple data type (like integer, bool, string etc.) or can be another complex JSON object. The general structure is as shown below:</p>
<pre><code>"variables": {
      "variable 1" : "value 1",
      "variable 2" : "value 2",
      "variable 3" : 1024,
      "variable 4" : {}
}</code></pre>
<p>Note that in the above example, the first 3 variables are of simple value type. The 4rth variable is however of a complex JSON object type.</p>
<p>Let's now check a real variables section from an actual ARM template:</p>
<pre><code>"variables": {
        "vmSize": "Standard_A2",
        "virtualNetworkName": "MyVNETName",
        "vnetId1": "[resourceId('Microsoft.Network/virtualNetworks', variables('virtualNetworkName'))]",
        "vnetId2": "[resourceId(parameters('vNetRG'),'Microsoft.Network/virtualNetworks',parameters('virtualNetworkName'))]",
        "subnetRef": "[concat(variables('vnetId'), '/subnets/', variables('subnetName'))]",
        "vhdStorageName": "[concat('vhdstorage', uniqueString(resourceGroup().id))]",
        "storageAccountResourceGroup": "[resourcegroup().name]",
        "location": "[resourceGroup().location]",
        "subscriptionId": "[subscription().subscriptionId]"
    }</code></pre>
<p>There are lots of key constructs in the above code snippet. I have tried to capture as many different constructs in this snippets as I could. Let us decode each variable one by one.</p>
<ol>
<li>vmSize - Simple String</li>
<li>virtualNetworkName - Simple string name</li>
<li>vnetId1 - This uses a special function named &quot;<strong>resourceId</strong>&quot; to find out the resource ID of the virtual network. This function is invoked by using the syntax <code>"[resourceId(Input)]"</code> .  This gets the resource ID of a resource which is defined by the Input to this. Also, note the use of another variable as an input to this.</li>
<li>vnetId2 - This also fetches the resource Id of a virtual network using &quot;resourceId&quot; method. Note the use of the value of a parameter in this to find out Resource Group of the existing Virtual network (parameter &quot;vNetRG&quot;).</li>
<li>subnetRef - This variable uses another function &quot;<strong>concat</strong>&quot; in ARM template i.e. <code>"[concat(input1,input2,...)]"</code>. This function can take many inputs and will concatinate (i.e. club together) the value of all the inputs provided. You can use parameters or another variable.</li>
<li>vhdStorageName - This also uses concat function to dynamically generate a storage name. However it uses &quot;<strong>resourcegroup</strong>&quot; function as <code>"[resourcegroup()]"</code>. This function always returns the resource group to which you are deploying the current ARM template. Then the variable uses the id property of the resource group returned.</li>
<li>storageAccountResourceGroup - This uses the &quot;name&quot; property of the current resource group</li>
<li>location - This uses the &quot;location&quot; property of the current resource group.</li>
<li>subscriptionId - This uses the &quot;<strong>subscription</strong>&quot; function as <code>"[subscription()]"</code> to find out the current subscription to which the current ARM template is being deployed.  Then it uses the subscription Id property of the subscription to get the required Id.</li>
</ol>
<p>Note that these constructs are very powerfull and can be used to dynamically construct your ARM template. These constructs are also known as Helper Functions and are explained in detail here: <a href="../step-by-step-arm-templates-helper-functions/">Step by Step ARM Templates - Helper Functions</a></p>
<h3>Using Variables</h3>
<p>Using variables is very easy and is similar to using parameters. In fact, you already saw the usage of variables above, while defining other variables.</p>
<p>You use the square parenthesis to indicate to the ARM engine to evaluate whatever is inside the parenthesis. You use the &quot;variable&quot; keyword and then you pass the name of the variable as input. Check the example below.</p>
<pre><code>"storageAccountName": "[variables('storageAccountName')]"</code></pre>
<h3>Best Practices</h3>
<p>Best practices are similar to the Parameters.</p>
<ul>
<li>Provide complete descriptive names, no matter how long.</li>
<li>Use <strong>Pascal Casing</strong> to name your parameters. i.e. First letter should be a small letter. Then every new word will have the first letter as a capital. No space between words. E.g. storageAccountName</li>
<li>Use the constructs explained in the previous section to dynamically generate variables. This reduces any human errors.</li>
<li>Anything that is used more than once and is not required to be entered by an end user, should be created as a variable. Later on, this helps by minimizing the number of places you need to change the value.</li>
</ul>
<p>That's all there is to Variables in ARM Templates. If you have any doubts, please comment in the below section. Use the links at the Top to know all about other components in an ARM Template.</p>]]></description>
<link>http://HarvestingClouds.com/post/step-by-step-arm-templates-what-is-in-an-arm-template-understanding-components-3-variables</link>
<pubDate>Fri, 26 Aug 2016 00:00:00 +0500</pubDate>
</item>
<item>
<title>Step by Step ARM Templates - What is in an ARM Template - Understanding Components 2 - Parameters</title>
<description><![CDATA[<p>If you haven't checked the previous blog on the overall structure of the ARM template, I suggest you give it a quick read before checking the component described in this post in detail.</p>
<ol>
<li><a href="../step-by-step-arm-templates-what-is-in-an-arm-template-understanding-all-components/">Understanding all components</a></li>
<li><a href="../step-by-step-arm-templates-what-is-in-an-arm-template-understanding-components-2-parameters/">Parameters - This blog post</a></li>
<li><a href="../step-by-step-arm-templates-what-is-in-an-arm-template-understanding-components-3-variables/">Variables</a></li>
<li><a href="../step-by-step-arm-templates-what-is-in-an-arm-template-understanding-components-4-resources/">Resources</a></li>
<li><a href="../step-by-step-arm-templates-what-is-in-an-arm-template-understanding-components-5-outputs/">Outputs</a></li>
</ol>
<h2>Parameters</h2>
<p>As mentioned earlier, parameters are the way to customize the templates, each time you deploy it to create resources in Azure. These parameters are the end-user inputs for various aspects of the template. E.g. If you are deploying an Azure Virtual Machine via an ARM Template then the name of the VM can be an input parameter. Operating System type can be another parameter.</p>
<p>The parameters can be referred and used in other parts of the ARM Template.</p>
<h3>1. Defining Parameters</h3>
<p>Parameters is a one huge JSON object with multiple JSON properties. Each property is one parameter which is represented as another JSON object. Let us look at its structure at a high level.</p>
<pre><code>"parameters": {
               "parameter 1" : {},
               "parameter 2" : {},
               "parameter 3" : {}
}</code></pre>
<p>E.g. If you are creating a template to deploy a Windows Virtual Machine then the parameters will look something like below:</p>
<pre><code>"parameters": {
               "VMName" : {},
               "AdminUserName" : {},
               "AdminPassword" : {},
               "WindowsOSVersion" : {}
}</code></pre>
<p>Now let us look at one of the parameters. E.g. The AdminUserName parameter will look like:</p>
<pre><code>"adminUsername": {
            "type": "string",
            "minLength": 1,
            "metadata": {
                "description": "Username for the Virtual Machine."
            }
        }</code></pre>
<p>The parameter object, as shown above, has following parts:</p>
<ol>
<li><strong>Type</strong> - This is the data Type of the parameter.</li>
<li><strong>minLength</strong> - This is the minimum length the parameter must have</li>
<li><strong>Metadata</strong> - This is just to provide a description as to what the parameter means.</li>
</ol>
<p>The <strong>Data Type</strong> allowed for the parameter are:</p>
<ul>
<li>string or secureString – any valid JSON string</li>
<li>int – any valid JSON integer</li>
<li>bool – any valid JSON boolean </li>
<li>object – any valid JSON object </li>
<li>array – any valid JSON array</li>
</ul>
<p>A more complex parameter e.g. Windows OS Version, with few more properties, is shown below:</p>
<pre><code>"windowsOSVersion": {
            "type": "string",
            "defaultValue": "2012-R2-Datacenter",
            "allowedValues": [
                "2008-R2-SP1",
                "2012-Datacenter",
                "2012-R2-Datacenter"
            ],
            "metadata": {
                "description": "The Windows version for the VM. This will pick a fully patched image of this given Windows version. Allowed values: 2008-R2-SP1, 2012-Datacenter, 2012-R2-Datacenter."
            }
        }</code></pre>
<p>It has additional below properties:</p>
<ol>
<li><strong>Default Value</strong> - This is the default value. End User will be able to change this value when deploying the template. If no value is provided then this value is picked.</li>
<li><strong>Allowed Values</strong> - This is an Array of values which are allowed for the parameter. Only value from this set is allowed as an input.</li>
</ol>
<h3>2. Using Parameters</h3>
<p>Using parameters is easy. Wherever in your template (in variables or resources section) you want to use the value of a parameter, just use the parameter function as shown below with the name of the parameter as input, enclosed in square brackets. </p>
<pre><code>[parameters('windowsOSVersion')]</code></pre>
<p>If the parameter value is assigned to a property, enclosing it in double quotes, as shown below:</p>
<pre><code>"sku": "[parameters('windowsOSVersion')]"</code></pre>
<h3>3. Best Practices</h3>
<ul>
<li>Try to always provide Default Values</li>
<li>Provide metadata so that you can provide insight as to what the parameter is meant for</li>
<li>Provide complete descriptive names, no matter how long.</li>
<li>Use <strong>Pascal Casing</strong> to name your parameters. i.e. First letter should be a small letter. Then every new word will have the first letter as a capital. No space between words. E.g. windowsOSVersion</li>
<li>Use properties like minLength and Allowed values to impose restrictions. This reduces any human errors.</li>
</ul>
<p>That's all there is to Parameters in ARM Templates. If you have any doubts, please comment in the below section. Use the links at the Top to know all about other components in an ARM Template.</p>]]></description>
<link>http://HarvestingClouds.com/post/step-by-step-arm-templates-what-is-in-an-arm-template-understanding-components-2-parameters</link>
<pubDate>Wed, 24 Aug 2016 00:00:00 +0500</pubDate>
</item>
<item>
<title>Step by Step ARM Templates - What is in an ARM Template - Understanding All Components</title>
<description><![CDATA[<p>As we discussed <a href="../step-by-step-azure-resource-manager-arm-templates-index/">earlier in the introduction</a> <strong>Azure Resource Manager (ARM) Template</strong> is a JavaScript Object Notation (JSON) file that defines one or more resources to deploy to a resource group. It also defines the dependencies between the deployed resources.</p>
<p>In this post, we will deconstruct any basic ARM template and will understand it's various components.</p>
<p>Any ARM Template will look like below:</p>
<pre><code>{
    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
    "contentVersion": "1.0.0.0",
    "parameters": {},
    "variables": {},
    "resources": [ {}, {} ]
}</code></pre>
<p>Snapshot of the Template at root level, as generated via Visual Studio:</p>
<p><img src="http://HarvestingClouds.com/images/147520488857edd71873f9b.png" alt="ARM Template Components" /></p>
<p>As you can see the components (or properties) of any ARM template includes:</p>
<ol>
<li>Schema</li>
<li>Content Version</li>
<li>Parameters</li>
<li>Variables</li>
<li>Resources</li>
</ol>
<p>Let's look at these in more detail.</p>
<table border="1" cellpadding="4" cellspacing="4">
        <colgroup>
            <col>
            <col>
            <col>
            <col>
        </colgroup>
        <tbody valign="top">
            <tr>
                <th>Element name</th>
                <th>Required</th>
                <th>JSON Type</th>
                <th>Description</th>
            </tr>
            <tr>
                <td>$schema</td>
                <td>Yes</td>
                <td>String Value</td>
                <td>Location of the JSON schema file that describes the version of the template language.</td>
            </tr>
            <tr>
                <td>contentVersion</td>
                <td>Yes</td>
                <td>String Value</td>
                <td>Version of the template (such as 1.2.0.20). When deploying resources using the template, this value can be used to make sure that the right template is being used.</td>
            </tr>
            <tr>
                <td>parameters</td>
                <td>No</td>
                <td>JSON Object</td>
                <td>Values that are provided by the end user (manually or via a parameters file) when deployment is executed to customize resource deployment.</td>
            </tr>
            <tr>
                <td>variables</td>
                <td>No</td>
                <td>JSON Object</td>
                <td>Values that are reused multiple times in the template. You can update these values. They are different from Parameters as their value is known and they are not required as inputs from the end user.</td>
            </tr>
            <tr>
                <td>resources</td>
                <td>Yes</td>
                <td>Array of Objects</td>
                <td>Types of services that are deployed or updated in a resource group. Each JSON object in this Array denotes an Azure Resource.</td>
            </tr>
            <tr>
                <td>outputs</td>
                <td>No</td>
                <td>JSON Object</td>
                <td>Values that are returned after deployment.</td>
            </tr>
        </tbody>
</table>
<p>Now that you know what each part is at a high level, in the next posts, we will look at the key 4 components in detail.</p>
<ol>
<li><a href="../step-by-step-arm-templates-what-is-in-an-arm-template-understanding-components-2-parameters/">Parameters</a></li>
<li><a href="../step-by-step-arm-templates-what-is-in-an-arm-template-understanding-components-3-variables/">Variables</a></li>
<li><a href="../step-by-step-arm-templates-what-is-in-an-arm-template-understanding-components-4-resources/">Resources</a></li>
<li><a href="../step-by-step-arm-templates-what-is-in-an-arm-template-understanding-components-5-outputs/">Outputs</a></li>
</ol>]]></description>
<link>http://HarvestingClouds.com/post/step-by-step-arm-templates-what-is-in-an-arm-template-understanding-all-components</link>
<pubDate>Mon, 22 Aug 2016 00:00:00 +0500</pubDate>
</item>
<item>
<title>Step by Step ARM Templates - JSON 101 for IT Administrators</title>
<description><![CDATA[<p>Azure Resource Manager (ARM) templates are written in JSON or <strong>JavaScript Object Notation</strong>. To understand ARM templates, you need to understand few quick basics about JSON. These will enable you to lay a great foundation which will enable you to understand ARM templates very easily.</p>
<p>JSON or JavaScript Object Notation (pronounce like &quot;Jay-son&quot;) is a text-based data format that's designed to be human-readable, lightweight, and easy to transmit between a server and a web client. Its syntax is derived from JavaScript. Think of this as an even more compact version of XML files.</p>
<p>JSON is a popular notation for transmitting data through RESTful web services. The official internet media type for JSON is <code>application/json</code>, and JSON files typically have a <code>.json</code> extension.</p>
<p>To understand JSON we need to understand <strong>3 main components</strong>. These components are like building blocks, using which you can build very complex JSON files.</p>
<h2>1. Objects</h2>
<p>Objects are the heart of JSON. Object denotes a real life object, e.g. an Employee. Just like a real life object, these have various properties and a value for each of these properties. E.g. An Employee will have Name property with value as John. Further, an employee object can have various another properties like Age, Salary, Department etc. So to denote an object in JSON you:</p>
<ul>
<li>One object will be represented by curly brackets. It will begin from opening curly bracket i.e. <code>{</code> and will end at closing curly bracket i.e. <code>}</code></li>
<li>Denote the property and corresponding values as <code>"key" : "value"</code> or <code>"property" : "value"</code> pairs.</li>
<li>You can only use double quotes for Properties as they will always be of type string</li>
<li>You will have double quotes around Values if they are of string type. You will not have any quotes in case of a number or a boolean value.</li>
<li>Each property will be separated from next property by a comma</li>
</ul>
<p><strong>Note:</strong> Each JSON file is also a single JSON object. At root level it starts with an opening curly bracket i.e. <code>{</code> and will end with closing curly bracket i.e. <code>}</code>. There can't be any other objects at the root level. Think of this similar to how in an XML file there can be only one element at the root level. </p>
<p>Example Employee object is shown below:</p>
<pre><code>{
    "Name" : "John",
    "Age" : 34,
    "Department" : "Finance",
    "Salary" : "100000",
    "IsAdmin" : true
}</code></pre>
<h2>2. Arrays</h2>
<p>Simply put, arrays are a collection of items. In JSON the <strong>square brackets</strong> represents an Array. E.g. An array of 3 employees will look like below:</p>
<pre><code>[
  {
        "Name" : "John",
        "Age" : 34
    },
   {
        "Name" : "Mary",
        "Age" : 32
    },
   {
        "Name" : "Matthew",
        "Age" : 29
    }
]</code></pre>
<h2>3. Nesting of Objects</h2>
<p>Now things get more interesting with nesting of Objects. What Nesting means is that one object can have it's property as another complex object. Don't worry if that sounds confusing. Let's understand that statement using an example. An Address where a person lives can be represented by an object. This object will look like below:</p>
<pre><code>{
  "StreetNumber" : "50",
  "StreetName" : "Brian Harrison Way",
  "Unit Number" : 22,
  "City" : "Toronto",
  "Country" : "Canada"
}</code></pre>
<p>Now an Employee Object will have an Address object as one of it's property (because employee need to live somewhere). This new complex Employee object will look like below, with nested Address object as one of it's property:</p>
<pre><code> {
        "Name" : "John",
        "Age" : 34,
        "Department" : "Finance",
        "Salary" : "100000",
        "IsAdmin" : true,
        "Address" :   {
                          "StreetNumber" : "50",
                          "StreetName" : "Brian Harrison Way",
                          "Unit Number" : 22,
                          "City" : "Toronto",
                          "Country" : "Canada"
                       }
    }</code></pre>
<p>That's all there is to it. Now you can use these 3 components and build very complex json files/templates. Even the most complex template can be broken into these 3 components. </p>
<p>Below is a complex example with all 3 components. </p>
<pre><code>{
    "Department": "Finance",
    "TotalEmployees": 2,
    "Employees": [
        {
            "Name": "John",
            "Age": 34,
            "Department": "Finance",
            "Salary": "100000",
            "IsAdmin": true,
            "Address": {
                "StreetNumber": "50",
                "StreetName": "Brian Harrison Way",
                "Unit Number": 22,
                "City": "Toronto",
                "Country": "Canada"
            }
        },
        {
            "Name": "John",
            "Age": 34,
            "Department": "Finance",
            "Salary": "100000",
            "IsAdmin": true,
            "Address": {
                "StreetNumber": "50",
                "StreetName": "Brian Harrison Way",
                "Unit Number": 22,
                "City": "Toronto",
                "Country": "Canada"
            }
        }
    ]
}</code></pre>
<p>The above JSON object denotes one department with name as Finance and total number of employees as 2. Then the &quot;Employees&quot; object is an array of 2 emplyees. Each emplyee object further have a complex property as Address, which is another object. </p>
<p>If you understood each of the 3 components, you should be able to build/understand most complex JSON files with ease.</p>]]></description>
<link>http://HarvestingClouds.com/post/step-by-step-arm-templates-json-101-for-it-administrators</link>
<pubDate>Wed, 17 Aug 2016 00:00:00 +0500</pubDate>
</item>
<item>
<title>ASR Setup for VMs running in VMWare without VMware level User Access</title>
<description><![CDATA[<h3>Problem Statement</h3>
<p>Recently I was setting up <strong>Azure Site Recovery</strong> (or ASR) in an environment. We had multiple VMs in VMWare environment. The environment was managed by Third Party who did not want to give any service account for VMWare as their environment was shared with different customers. So we had access only to the VMs. Without relevant access, ASR for VMWare was out of the question for us.</p>
<h3>Solution</h3>
<p>We treated the VMs, in such environment, as physical machines when setting up ASR to replicate these machines to Azure.
We used the option of &quot;<strong><em>Not virtualized/other</em></strong>&quot; in the &quot;<strong><em>Prepare Infrastructure</em></strong>&quot; wizard of ASR. We <strong>treated the VMs as physical servers</strong> and did not face any issues during the migration. </p>
<p>Refer below screenshot for the exact option discussed above.</p>
<p><img src="http://HarvestingClouds.com/images/14696297155798c513ea908.png" alt="Protection Goal" /></p>
<p>Later when enabling the Replication for any Server, run the &quot;<strong><em>Enable Replication</em></strong>&quot; wizard by clicking on &quot;<strong>+Replicate</strong>&quot; on the ASR vault's blade. Then select &quot;<strong>Machine Type</strong>&quot; as &quot;<strong><em>Physical Machine</em></strong>&quot; and add the Physical Machines by mentioning their IP addresses. </p>
<p><strong>Note:</strong> For this approach to work, the Configuration server should be on the same network as the VM being considered as Physical Machine.</p>
<p>We were able to migrate many servers successfully and without any issues using this approach.</p>]]></description>
<link>http://HarvestingClouds.com/post/asr-setup-for-vms-running-in-vmware-without-vmware-level-user-access</link>
<pubDate>Tue, 26 Jul 2016 00:00:00 +0500</pubDate>
</item>
<item>
<title>Uploading and Downloading files securely from Azure Storage Blob via PowerShell</title>
<description><![CDATA[<p><strong>Azure blob storage</strong> can provide a very highly available way to store your files in the cloud. You can dynamically add or remove the files in an automated fashion. These files can then be used for any number of purposes. E.g. A parameter file for ARM template can be kept in Azure blob storage and then dynamically read while creating resources from an ARM template.</p>
<p><strong>The whole process can be broken down into 3 parts</strong>:</p>
<ol>
<li>Generating the context to the storage container</li>
<li>Uploading the files using the context</li>
<li>Downloading the files using the context</li>
</ol>
<h3>1. Generating the context to the storage container</h3>
<p>The context to the storage blob container can be created in one of the 3 ways, based on your security requirements. All methods use the <code>New-AzureStorageContext</code> cmdlet to generate the storage context. The methods differ on how you pass the parameters to this cmdlet.</p>
<p><strong>A. Via fetching the Azure Storage Key</strong></p>
<p>This first method uses the <code>Get-AzureStorageKey</code> to fetch the storage key. This key is then used to generate the context as shown below.</p>
<pre><code>$StorageAccountName = "yourstorageaccount"
$StorageAccountKey = Get-AzureStorageKey -StorageAccountName $StorageAccountName
$Ctx = New-AzureStorageContext $StorageAccountName -StorageAccountKey $StorageAccountKey.Primary</code></pre>
<p><strong>B. Via fetching the Azure Storage Container SAS Token</strong></p>
<p>This second method uses the <code>New-AzureStorageContainerSASToken</code> to create a new SAS token to securely access the storage container. This token is then used to generate the context as shown below.</p>
<pre><code>$sasToken = New-AzureStorageContainerSASToken -Container abc -Permission rl
$Ctx = New-AzureStorageContext -StorageAccountName $StorageAccountName -SasToken $sasToken</code></pre>
<p><strong>C. Via Connectin String</strong></p>
<p>This third method uses a connection string, entered manually, which is then used to generate the context as shown below.</p>
<pre><code>$ConnectionString = "DefaultEndpointsProtocol=http;BlobEndpoint=&lt;blobEndpoint&gt;;QueueEndpoint=&lt;QueueEndpoint&gt;;TableEndpoint=&lt;TableEndpoint&gt;;AccountName=&lt;AccountName&gt;;AccountKey=&lt;AccountKey&gt;"
$Ctx = New-AzureStorageContext -ConnectionString $ConnectionString</code></pre>
<h3>2. Uploading the files using the context</h3>
<p>Now that you have the context to the storage account you can upload and download files from the storage blob container.
Use the below code to upload a file named &quot;<em>Parameters.json</em>&quot;, located on the local machine at &quot;<em>C:\Temp</em>&quot; directory.</p>
<pre><code>#Uploading File
$BlobName = "Parameters.json"
$localFile = "C:\Temp\" + $BlobName

#Note the Force switch will overwrite if the file already exists in the Azure container
Set-AzureStorageBlobContent -File $localFile -Container $ContainerName -Blob $BlobName -Context $Ctx -Force</code></pre>
<h3>3. Downloading the files using the context</h3>
<p>Download works in almost identical manner. You use the Get cmdlet instead of Set as shown below to download a file to a local folder, located at &quot;<em>C:\Downloads</em>&quot;.</p>
<pre><code>#Download File
$BlobName = "Parameters.json"
$localTargetDirectory = "C:\Downloads"

Get-AzureStorageBlobContent -Blob $BlobName -Container $ContainerName -Destination $localTargetDirectory -Context $ctx</code></pre>
<p>I hope this helps simplify the automated usage of Azure Storage container. Let us know your concerns or questions if any.</p>
<p><strong>Reference:</strong> <a href="https://azure.microsoft.com/en-us/documentation/articles/storage-powershell-guide-full/" target="_blank">Using Azure PowerShell with Azure Storage</a></p>]]></description>
<link>http://HarvestingClouds.com/post/uploading-and-downloading-files-securely-from-azure-storage-blob-via-powershell</link>
<pubDate>Wed, 18 May 2016 00:00:00 +0500</pubDate>
</item>
<item>
<title>Azure comes to Canada (along with Office 365)</title>
<description><![CDATA[<p>Last week marked the general availability of Azure datacenter for Canada locations. Also Office 365 has been released last week. Microsoft has set up 2 new datacenters in Canada. </p>
<h3>Where Exactly are these datacenters located</h3>
<ol>
<li><strong>Canada Central</strong> - The first datacenter is located in Toronto.</li>
<li><strong>Canada East</strong> - The second datacenter is located in Quebec City.</li>
</ol>
<p>Now when you are creating a new resource (like a Virtual Machine) you will see these two options.</p>
<p><img src="http://HarvestingClouds.com/images/1463686879573e16df4f64c.png" alt="New Locations" /></p>
<p>Check out the brief announcement video by <strong>Janet Kennedy</strong>, President of Microsoft Canada:</p>
<iframe src="https://channel9.msdn.com/Blogs/CANITPRO/The-Microsoft-Canada-Cloud-is-Open-for-Business/player" width="560" height="315" allowFullScreen frameBorder="0"></iframe>
<h3>Key Resources:</h3>
<ul>
<li>These locations are also listed in the official Microsoft Regions list here: <a href="https://azure.microsoft.com/en-us/regions/#services?WT.mc_id=azurebg_email_Trans_1106_Tier2_Release_MOSP" target="_blank">Azure Regions</a></li>
<li>Various resources and information for cloud in Canada are available here at <a href="https://www.microsoft.com/en-ca/sites/datacentre/default.aspx" target="_blank">Cloud Accelerate site for Canada</a>.</li>
<li>You can read about this announcement and upcoming features here: <a href="https://azure.microsoft.com/en-us/blog/microsoft-cloud-accelerates-in-canada-and-expands-to-south-korea/?WT.mc_id=azurebg_email_Trans_1106_Tier2_Release_MOSP" target="_blank">Microsoft Cloud accelerates in Canada and expands to South Korea</a></li>
</ul>]]></description>
<link>http://HarvestingClouds.com/post/azure-comes-to-canada-along-with-office-365</link>
<pubDate>Mon, 16 May 2016 00:00:00 +0500</pubDate>
</item>
<item>
<title>NEW Feature - Azure Cool Blob Storage</title>
<description><![CDATA[<p>Have you heard about the new <strong>Azure Cool Blob Storage</strong>? </p>
<p>If you haven’t heard about it, this is Microsoft's low-cost storage for <strong>Cool</strong> object data. “Example use cases for cool storage include backups, media content, scientific data, compliance and archival data. In general, any data which lives for a longer period of time and is accessed less than once a month is a perfect candidate for cool storage.” It is similar to what <strong>Glacier storage tier</strong> provides in Amazon Web Services.</p>
<ul>
<li><strong>Pricing:</strong> Its cost is as low as $0.01/GB.</li>
<li><strong>Availability:</strong> 99% (as compared to 99.9% for Hot Storage). With Read-access geo-redundant storage (or RA-GRS) the SLA is 99.9% (as compared to 99.99% for Hot).</li>
<li><strong>Deciding which AccessTier to use:</strong> If the objects in the storage account will be more frequently accessed, then go with <strong>Hot Tier</strong>. Select the <strong>Cold Tier</strong> for infrequently accessed data.</li>
</ul>
<p>Now when you go to New -&gt; &quot;Data + Storage&quot; -&gt; Storage Account, and try to create a Blob Storage account then you can select from one of the options for <strong>Access Tier</strong> from Cold or Hot tier. </p>
<p><img src="http://HarvestingClouds.com/images/146232375357294a2980ece.png" alt="Storage Tiers" /></p>
<p>Also, note that at the time of this writing, Blob storage account is <strong>only available in these locations</strong>: Central US, East US 2, North Central US, North Europe, West Europe, Southeast Asia, Japan East, Japan West, Central India, South India, West India.</p>
<p><strong>Resources to know more:</strong>  </p>
<ul>
<li><a href="https://azure.microsoft.com/en-us/blog/introducing-azure-cool-storage/" target="_blank">Official Announcement</a></li>
<li><a href="https://azure.microsoft.com/en-us/documentation/articles/storage-blob-storage-tiers/" target="_blank">Getting started guide</a></li>
</ul>]]></description>
<link>http://HarvestingClouds.com/post/new-feature-azure-cool-blob-storage</link>
<pubDate>Mon, 02 May 2016 00:00:00 +0500</pubDate>
</item>
<item>
<title>Taking Automatic Remediation Action on Azure VM Alert Generation</title>
<description><![CDATA[<p>Using a new feature in Azure, now you can easily configure to trigger an Azure Automation Runbook when an Alert is triggered on an Azure Virtual Machine to take a remediation action. To leverage this feature all you need to do is link the alert on Azure VM to an already existing Azure Automation Runbook.</p>
<blockquote>
<p>Note: This feature is supported only for the V2 Virtual Machines, i.e. the VMs created using ARM portal.</p>
</blockquote>
<p>To access this feature open your Virtual Machine. Then go to the Manage alerts section in the Settings:</p>
<p><img src="http://HarvestingClouds.com/images/14618976705722c9c653752.png" alt="Setting - Manage alerts" /></p>
<p>Then open an existing alert or click on &quot;Add alert&quot; to create a new one. Specify the criteria for the alert. Scroll down to the bottom and you can view the new section to link the alert to an Automation Runbook.</p>
<p><img src="http://HarvestingClouds.com/images/14618990795722cf4763dce.png" alt="Automation Runbook for Alert" /></p>
<h3>Under the hood</h3>
<p>The alert will send data to your Runbook in a special format. Your Runbook should be expecting this. Under the hood this happens via WebHooks. The alert data is passed via a HTTP POST request. The Automation webhook service extracts the alert data from the POST request and passes it to the runbook in a parameter called <strong>&quot;WebhookData&quot;</strong>. The Runbook will look like below:</p>
<pre><code>[OutputType("PSAzureOperationResponse")]

param ( [object] $WebhookData )

if ($WebhookData)
{
    # Get the data object from WebhookData
    $WebhookBody = (ConvertFrom-Json -InputObject $WebhookData.RequestBody)

    #Rest of the script comes here
}</code></pre>
<p><strong>In Nutshell</strong>, now you can now trigger Azure Automation Runbooks to take remediation actions on Virtual Machines in case an alert is triggered. </p>
<p><strong>Reference with complete Runbook sample:</strong> <a href="https://azure.microsoft.com/en-us/documentation/articles/automation-azure-vm-alert-integration/">Azure Automation solution - remediate Azure VM alerts</a></p>]]></description>
<link>http://HarvestingClouds.com/post/taking-automatic-remediation-action-on-azure-vm-alert-generation</link>
<pubDate>Wed, 27 Apr 2016 00:00:00 +0500</pubDate>
</item>
<item>
<title>ROADMAP - Solutions to help with Migration from Azure ASM to ARM portal</title>
<description><![CDATA[<p>In additional to the tool I mentioned yesterday regarding <a href="http://harvestingclouds.com/Migrating-from-Azure-ASM-to-ARM-portal">Migrating from Azure ASM to ARM portal</a> there are various solutions in the pipeline. This post looks at the high level Roadmap for the same from Microsoft.</p>
<p>Microsoft has promised that they are committed to make the migration more easier from ASM (older) to ARM (newer) portal. Various solutions are already in the pipeline for this.
Below are the details and roadmap for the tentative timelines for these solutions.</p>
<table border="1" cellpadding="0" cellspacing="0"> <tbody> <tr> <td valign="top" width="29%"> <p><b>Solution</b></p> </td> <td valign="top" width="51%"> <p><b>Customer Experience</b></p> </td> <td valign="top" width="18%"> <p><b>Expected availability in 2016</b></p> </td> </tr> <tr> <td valign="top" width="29%"> <p>Script migration</p> </td> <td valign="top" width="51%"> <p>VM is rebooted as it is recreated in the Resource Manager model. While the Virtual Machines for the environment are recreated, the network is disconnected.</p> </td> <td valign="top" width="18%"> <p align="center">Q1</p> </td> </tr> <tr> <td valign="top" width="29%"> <p>Virtual Machines, no VNET</p> </td> <td valign="top" width="51%"> <p>As all Virtual Machines deployed in the Resource Manager model must be in a VNet, Virtual Machines will be migrated and placed in a new VNET. This will result in a change in network configuration, requiring a reboot to reconnect.</p> </td> <td valign="top" width="18%"> <p align="center">Q2</p> </td> </tr> <tr> <td valign="top" width="29%"> <p>Virtual Machines with VNET</p> </td> <td valign="top" width="51%"> <p>Starting in Q2, the platform will offer Virtual Machine migration from ASM to Resource Manager model without disrupting the running Virtual Machine. This will require disconnecting any VNets connected on-premises, whether via ExpressRoute or VPN, before doing the migration.</p> </td> <td valign="top" width="18%"> <p align="center">Q2</p> </td> </tr> <tr> <td valign="top" width="29%"> <p>Virtual Machines with basic hybrid (one connection)</p> </td> <td valign="top" width="51%"> <p>Starting in Q3, the platform will offer Virtual Machine migration from ASM to Resource Manager model without disrupting the running Virtual Machine and with minimal disruption to a basic hybrid connection, limited to just one connection back on-premises. More complex connections will require disconnecting before doing the migration.</p> </td> <td valign="top" width="18%"> <p align="center">Q3</p> </td> </tr> </tbody> </table>
<p>Reference: <a href="https://azure.microsoft.com/en-us/blog/transitioning-to-the-resource-manager-model/">Transitioning to the Resource Manager model</a></p>]]></description>
<link>http://HarvestingClouds.com/post/roadmap-solutions-to-help-with-migration-from-azure-asm-to-arm-portal</link>
<pubDate>Fri, 22 Apr 2016 00:00:00 +0500</pubDate>
</item>
<item>
<title>Migrating from Azure ASM to ARM portal</title>
<description><![CDATA[<p>With co-existing Azure Service Management or ASM portal (older) and Azure Resource Manager or ARM portal (newer) there has been lots of confusions and problems for IT administrators.
The bottom line of all the discussion around the two portals is that <strong>ARM is the future and is here to stay</strong>. It means that you need to <strong>plan and migrate</strong> your resources from ASM portal to the ARM portal.</p>
<p>The key resource is your infrastructure which primarily consists of virtual machines. To migrate a single Virtual Machine (VM) from ASM portal to ARM portal you can leverage a set of PowerShell scripts called ASM2ARM.
You can download these scripts and check their description on <a href="https://github.com/fullscale180/asm2arm">GitHub here on the <strong>ASM2ARM</strong> page</a>. You can check the detailed instructions there too.</p>
<p>To plan this right now is very important as the transitioning to Azure Resource Manager model is already underway. Any future development and investment seems to be happening only in the newer portal only.</p>
<p><strong>Reference:</strong> <a href="https://github.com/fullscale180/asm2arm">ASM2ARM scripts on GitHub</a></p>]]></description>
<link>http://HarvestingClouds.com/post/migrating-from-azure-asm-to-arm-portal</link>
<pubDate>Thu, 21 Apr 2016 00:00:00 +0500</pubDate>
</item>
<item>
<title>PowerShell DSC - Partial Configurations</title>
<description><![CDATA[<p><strong>Partial Configurations</strong> is a new feature in PowerShell 5.0 Desired State Configuration or DSC. It allows the configurations to be delivered in parts or fragments. These configurations can come from various sources.
The Local Configuration Manager or LCM on the target node puts these partial configurations from different sources together and after that apply the same as a single configuration.</p>
<p>This opens various possibilities for Enterprises to manage their infrastructure and designate the responsibility to various teams for a single node. The team expert in a particular field can focus on that feature without worrying about other features.</p>
<p>You can have partial configurations in following modes:</p>
<ol>
<li>Push Mode</li>
<li>Pull Mode</li>
<li>Hybrid Mode (i.e. combination of Push and Pull)</li>
</ol>
<h3>Configuration for the PUSH Mode</h3>
<p>You need to follow three steps to configure Partial configurations for the PUSH mode:</p>
<ul>
<li>Configure the LCM, on the target node, to expect partial configurations</li>
<li>Push each partial configuration from different sources using <strong>Publish-DSCConfiguration</strong> cmdlet. Target node will automatically combine the partial configurations into single configuration.</li>
<li>Apply the configuration by calling the <strong>Start-DSCConfiguration</strong>cmdlet</li>
</ul>
<h3>Configuration for the PULL Mode</h3>
<p>This is bit complex than the Push mode. In nutshell you only need couple of steps:</p>
<ul>
<li>Configure the LCM, on the target node, to receive partial configurations but from PULL servers</li>
<li>Name and locate the configuration documents properly on the pull servers</li>
</ul>
<p>To know more about DSC Partial configurations follow the below references:</p>
<ul>
<li><a href="https://automationnext.wordpress.com/2016/04/19/powershell-desired-state-configuration-partial-configurations-without-configurationid/">Detailed Blog by AutomationNext with very valuable insights</a></li>
<li><a href="https://msdn.microsoft.com/en-us/powershell/dsc/partialconfigs">Official MSDN Article</a></li>
</ul>]]></description>
<link>http://HarvestingClouds.com/post/powershell-dsc-partial-configurations</link>
<pubDate>Wed, 20 Apr 2016 00:00:00 +0500</pubDate>
</item>
<item>
<title>Azure Container Service hits General Availability</title>
<description><![CDATA[<p>Azure Container Service has finally hit General Availability today. </p>
<p>If you don't know already, it is the &quot;container hosting solution&quot; which is optimized for Microsoft's Azure cloud.
All the tools that you may be familiar with when working with a Container Service should work like Apache Mesos or Docker Swarm. It only uses open source components in the orchestration layers to give you portability of full applications.</p>
<p>You can find the announcement here: <a href="https://azure.microsoft.com/en-us/updates/general-availability-azure-container-service/">GA for Azure Container Service</a></p>
<p>You can learn more about the Container Service as offered by Azure on the product page here: <a href="https://azure.microsoft.com/en-us/services/container-service/">Azure Container Service</a></p>]]></description>
<link>http://HarvestingClouds.com/post/azure-container-service-hits-general-availability</link>
<pubDate>Tue, 19 Apr 2016 00:00:00 +0500</pubDate>
</item>
<item>
<title>Azure Authentication - Authenticating any Azure API Request in your Application</title>
<description><![CDATA[<p>I have created a code sample to showcase how you can authenticate any request programatically with Azure.
This also contains <strong>a Reusable Authentication Helper class</strong> which you can directly use in your code.</p>
<h3>Where is the code</h3>
<p>You can find the complete code sample along with the reusable Azure Authentication Helper class library from this GitHub repo:
<a href="https://github.com/HarvestingClouds/AzureAuthentication">Azure Authentication Sample</a></p>
<h3>What are my authentication Options</h3>
<p>You have the following options</p>
<ul>
<li>Authenticating by <strong>Prompting</strong> for Credentials from end user. (This needs end user interaction)</li>
<li>Authenticating by <strong>Credentials</strong> i.e. using a password. (This does not need any end user interaction)</li>
<li>Authenticating by using a <strong>Certificate</strong> ( This also does not need any end user interaction)</li>
</ul>
<p>I have provided this functionality in 3 separate methods, in a separate class file along with it's interface.
You can follow the instructions in the ReadMe file in the GitHub repo and start using any one of the method.</p>
<p>I hope you find this usefull and this will avoid the trouble of figuring things out, which I have already undergone. </p>
<p>Let me know in the comments below if you have any questions or anything to add to this.</p>]]></description>
<link>http://HarvestingClouds.com/post/azure-authentication-authenticating-any-azure-api-request-in-your-application</link>
<pubDate>Fri, 15 Apr 2016 00:00:00 +0500</pubDate>
</item>
<item>
<title>Run Azure Automation Runbooks via PowerShell ISE</title>
<description><![CDATA[<p>Today I came across this blog post from my friend: <a href="https://scomanswers.wordpress.com/2016/04/11/azure-automation-powershell-ise-add-on/">Azure Automation PowerShell ISE add-on</a></p>
<p>What I came to know is that now you can Run the Azure Automation Runbooks via PowerShell ISE. This solves a big pain point for all Azure developers.
Now you will be able to develop and test your scripts right from the convenience of your laptop's local PowerShell ISE. </p>
<h3>What you need to do</h3>
<p>All you need to do is install the PowerShell Add-On using the below cmdlet:</p>
<pre><code class="language-powershell">Find-Module AzureAutomationAuthoringToolkit | Install-Module -Scope CurrentUser</code></pre>
<p>Then import the module using below cmdlet:</p>
<pre><code class="language-powershell">Import-Module AzureAutomationAuthoringToolkit</code></pre>
<p>You can configure the Add-On using a Configuration tab in the add-on and start getting your hands dirty. </p>
<h3>Official Information from the Add-On Help</h3>
<h4>Capabilities</h4>
<ul>
<li>Test runbooks on your local machine and in the Azure Automation service: </li>
<li>Store and edit Automation Assets locally </li>
<li>Use Automation Activities (Get-AutomationVariable, Get-AutomationPSCredential, etc) in local PowerShell scripts </li>
<li>Sync changes back to your Automation Account </li>
<li>Run test jobs in Automation and view results </li>
</ul>
<h4>Notes</h4>
<p>Assets</p>
<ul>
<li>Secret values (passwords, encrypted variables) are not downloaded automatically; they need to be set manually the first time the account is synced </li>
<li>Values that haven't been downloaded will be highlighted </li>
<li>Asset values you enter locally will not get overwritten when you sync from the cloud </li>
</ul>
<p>Runbooks </p>
<ul>
<li>Native PowerShell and PowerShell Workflow runbooks are supported </li>
</ul>
<p>Check the screenshot regarding this information below:
<img src="http://HarvestingClouds.com/images/1461735632572050d069253.png" alt="Official Notes" title="Official Notes" /></p>
<h3>How much time it would take me</h3>
<p>In all it would take you under 10 mins to get setup and rolling.</p>
<h3>Where is more information on this and screenshots</h3>
<p>Go to the official <a href="https://blogs.technet.microsoft.com/msoms/2016/04/08/the-way-cool-azure-automation-powershell-ise-add-on/">Technet blog by clicking HERE.</a></p>
<p>Start playing around and let us know your initial impression in the comments below. If you have any doubts and I will be happy to address them.</p>]]></description>
<link>http://HarvestingClouds.com/post/run-azure-automation-runbooks-via-powershell-ise</link>
<pubDate>Thu, 14 Apr 2016 00:00:00 +0500</pubDate>
</item>
<item>
<title>Various Options Added to Buy Microsoft Azure Active Directory Basic</title>
<description><![CDATA[<p>Today Microsoft announced that they have added various options to buy Microsoft Azure Active Directory (AAD) Basic.
You can now buy it through the Direct program as well as through following options:</p>
<ul>
<li><a href="https://www.microsoft.com/en-us/licensing/licensing-programs/enterprise.aspx?WT.mc_id=azurebg_email_Trans_1065_Tier2_Release_MOSP">Microsoft Enterprise Agreement</a></li>
<li><a href="https://www.microsoft.com/en-us/licensing/licensing-programs/open-license.aspx?WT.mc_id=azurebg_email_Trans_1065_Tier2_Release_MOSP">Open Volume License Program</a></li>
<li><a href="https://partner.microsoft.com/en-US/Solutions/cloud-reseller-overview?WT.mc_id=azurebg_email_Trans_1065_Tier2_Release_MOSP">Microsoft Cloud Solution Provider</a></li>
</ul>
<p>To purchase, sign in to the <a href="https://portal.office.com">Office 365 Administration Portal</a></p>
<p>You can also watch the below video for details. Although the video is for AAD Premium, the steps are essentially similar for AAD Basic.</p>
<iframe src="https://channel9.msdn.com/Series/Azure-Active-Directory-Videos-Demos/How-to-Purchase-Azure-Active-Directory-Premium-Existing-Customer/player" width="560" height="315" allowFullScreen frameBorder="0"></iframe>
<p>You can also engage a partner to assist you with the purchase and your Azure Active Directory related any requirements.
<a href="http://www.infrontconsulting.com/">Infront Consulting Group</a> (where I currently work) is one such partner who are highly respected in market and are Microsoft Gold Certified Partner. </p>
<p>Thanks for reading! If you have any questions please ask in the comments below.</p>]]></description>
<link>http://HarvestingClouds.com/post/various-options-added-to-buy-microsoft-azure-active-directory-basic</link>
<pubDate>Wed, 13 Apr 2016 00:00:00 +0500</pubDate>
</item>
<item>
<title>Multiple Values In Grid.Mvc Single Column Filter via Checkboxes with Code Sample</title>
<description><![CDATA[<p>I have been struggling to implement multiple filters in a single column in Grid.Mvc tool. I have solved this by altering the code and updating the custom widget.
<strong>Note:</strong> The WithMultipleFilters() option will not help you in this. That option enables multiple filters on different columns. To have multiple filters in the same column you need to update the way filtering works in the tool itself.</p>
<p>I have used a list of checkboxes and any or all of the elements selected in this checkbox list will be used for filtering the column values.</p>
<p>You can find the code in my fork of the official Grid.Mvc repo at below link:
<a href="https://github.com/HarvestingClouds/Grid.Mvc" target="_blank">Fork of Grid.Mvc repo with Advance Filters</a></p>
<p>I have also created a pull request for the same so that more people get benefit from this if they refer the master branch of the main repo.</p>
<h3>What are the changes I have done?</h3>
<p>I have made changes to two files:</p>
<ol>
<li><strong>DefaultColumnFilter.cs</strong> file in &quot;<strong>GridMvc</strong>&quot; class library project under the Filters folder. I have updated the GetFilterExpression method to create multiple expressions based on the pipeline character in filter values.</li>
<li><strong>gridmvc.customwidgets.js</strong> file in &quot;<strong>GridMvc.Site</strong>&quot; web application project</li>
</ol>
<p>Both of these paths are shown below:
Location of DefaultColumnFilter.cs:
<img src="http://HarvestingClouds.com/images/146173541957204ffb99678.png" alt="DefaultColumnFilter.cs" title="DefaultColumnFilter.cs" /></p>
<p>Location of gridmvc.customwidgets.js:
<img src="http://HarvestingClouds.com/images/146173543057205006529e6.png" alt="gridmvc.customwidgets.js" title="gridmvc.customwidgets.js" /></p>
<p>How the end result look like:
<img src="http://HarvestingClouds.com/images/14617354255720500171fe7.png" alt="Checkbox Filtering" title="Checkbox Filtering" /></p>
<p>You can directly use the code if you want. Just honor the license of the original author.</p>
<p>Let me know in the comments below if you have any doubts and I will be happy to address them.</p>]]></description>
<link>http://HarvestingClouds.com/post/multiple-values-in-gridmvc-single-column-filter-via-checkboxes-with-code-sample</link>
<pubDate>Tue, 12 Apr 2016 00:00:00 +0500</pubDate>
</item>
<item>
<title>Getting Started - Azure Site Recovery (ASR) In New Azure Portal</title>
<description><![CDATA[<p>Azure Site Recovery or ASR is now available in the new Azure Resource Manager or ARM portal (codename Ibiza) with modern user interface. It is in preview at this stage. But it is production ready for all the Hyper-V related scenarios.
<strong>Your older Vaults (created via Classic ASM Azure Portal) will not be available in ASR preview feature.</strong></p>
<h3>What are the new features</h3>
<p>The new features include:</p>
<ul>
<li>All the goodness of Azure Resource Manager in ASR</li>
<li>Lean experience for various ASR scenarios</li>
<li>Enhancements to the specific Site Recovery scenarios</li>
</ul>
<h3>Lets take a quick look at some of these.</h3>
<p>If you Browse and search for &quot;Recovery&quot; you get Recovery Services Vaults as Preview feature.
<img src="http://HarvestingClouds.com/images/14617358075720517f78904.png" alt="Browse and Search" title="Browse and Search" /></p>
<p>Clicking on it will open up the blade for &quot;Recovery Services valuts&quot;. Notice that Microsoft has PREVIEW text in this.
<img src="http://HarvestingClouds.com/images/1461735702572051161683f.png" alt="alt text" title="ASR Vault" /></p>
<p>Clicking on the Add button brings up the ASR vault creation blade. Notice the locations available for vault creation here.
<img src="http://HarvestingClouds.com/images/14617359385720520210878.png" alt="Vault Creation" title="Vault Creation" /></p>
<p>After you hit create the Vault gets deployed really quickly. I tested for East US location and it was created in under 10 secs.
Refresh to view your newly created vault. Click on it to open the NEW ASR Vault features. Notice that the Backup feature is also there in the ASR vault now.
<img src="http://HarvestingClouds.com/images/1461735907572051e31549a.png" alt="New Vault" title="New Vault" /></p>
<p>To find the options for replication go to Settings -&gt; Getting Started section -&gt; Site Recovery -&gt; Follow Wizard.
<img src="http://HarvestingClouds.com/images/1461735869572051bd2d6fa.png" alt="New Site Recovery Wizard" title="New Site Recovery Wizard" /></p>
<p>The Scenario Types available are only two. But all the scenarios are covered here:</p>
<ul>
<li>From my site to Azure</li>
<li>From my site to another site</li>
</ul>
<p>Based on the scenario you select you are asked for different options. The options for Virtualization/Management Server type for &quot;From my site to Azure&quot; are:</p>
<ul>
<li>VMM</li>
<li>Stand alone Hyper-V hosts</li>
<li>vCenter</li>
<li>Physical machines (not virtualized)
<img src="http://HarvestingClouds.com/images/14617358385720519e578ba.png" alt="Creation Options" title="Creation Options" /></li>
</ul>
<h3>Backup in ASR vault</h3>
<p>Another feature is creation of Backups from the same vault. Click on the + icon for Backup in the Vault main blade and then follow the wizard for the preview feature.
<img src="http://HarvestingClouds.com/images/14617357575720514d5d1d8.png" alt="Backup In ASR" title="Backup In ASR" />
Notice in the screenshot above that the backup types available are:</p>
<ul>
<li>Azure virtual machine backup</li>
<li>File Folder backup</li>
<li>System Center Data Protection Manager</li>
</ul>
<p>Selecting each option provides you with details for next steps. You can then create a backup policy and configure Items to backup.</p>
<p>Give these features a try and let us know in comments below how you find the new features.
Happy Exploring!</p>]]></description>
<link>http://HarvestingClouds.com/post/getting-started-azure-site-recovery-asr-in-new-azure-portal</link>
<pubDate>Sat, 09 Apr 2016 00:00:00 +0500</pubDate>
</item>
<item>
<title>Coming Soon - Windows 10 Anniversary Update</title>
<description><![CDATA[<p>Windows 10 Anniversary Update is coming this summary. It will be available for free download for the following devices (which is almost every device):</p>
<ul>
<li>PCs</li>
<li>Tablets</li>
<li>Phones</li>
<li>Xbox One</li>
<li>Microsoft HoloLens</li>
<li>IoT</li>
</ul>
<h2>What this means to you:</h2>
<ul>
<li>Improved Biometric Security</li>
<li>Microsoft Edge browser</li>
<li>Windows Ink (where just one click of pen will bring up all the gamut available for use with your Pen device)</li>
<li>Universal Windows Platform or UWP apps are coming to XBox through a Unified Windows Store. Also if you own a XBox you will be able to turn it into a dev box and do development with it</li>
<li>Various improvements to Cortana</li>
</ul>
<p><a href="https://www.microsoft.com/en-us/windows/upcoming-features" target="_blank">Check out more details here</a></p>]]></description>
<link>http://HarvestingClouds.com/post/coming-soon-windows-10-anniversary-update</link>
<pubDate>Fri, 08 Apr 2016 00:00:00 +0500</pubDate>
</item>
<item>
<title>Introducing Harvesting Clouds</title>
<description><![CDATA[<p>Harvesting Clouds is a blog about all things Cloud. Be it Private Cloud or Public Cloud, I will try to cover various aspects of both.</p>
<h3>Private Cloud</h3>
<p>My key areas of interest in Private Cloud include the following:</p>
<ul>
<li>PowerShell Scripting</li>
<li>Windows Azure Pack or WAP</li>
<li>Service Management Automation or SMA</li>
<li>Azure Stack</li>
<li>System Center Orchestrator</li>
<li>System Center VMM and other products like Service Manager, Ops Mgr, etc.</li>
</ul>
<h3>Public Cloud</h3>
<p>In addition to the Private Cloud the areas of interest in Public Cloud are:</p>
<ul>
<li>Microsoft Azure and Amazon Web Services - both IaaS and PaaS</li>
<li>Azure Automation</li>
<li>Desired State Configurations</li>
<li>Application Insights</li>
<li>Azure Web Apps</li>
<li>Web APIs</li>
<li>Azure Site Recovery and Backup</li>
<li>Migrations from Private to Public Clouds</li>
</ul>
<h3>Common Areas &amp; Best of both worlds</h3>
<p>I have also been involved in creating Hybrid clouds leveraging the best of both worlds. I will try to share my knowledge on this with you. The key aspects in this area are:</p>
<ul>
<li>Building Hybrid Solutions</li>
<li>Developing Web or Desktop Applications targetting either or both the clouds (using MVC, Dot Net)</li>
<li>Using TFS Online, Visual Studio, GitHub to better collaborate and work in an automated fashion</li>
<li>Release Manager to automate your release workflows</li>
</ul>
<h3>Primary Focus</h3>
<p>As you must have guessed by now, the primary focus for this blog will be Microsoft Technologies. We will also explore beyond this and will be talking about various emerging open source technologies and the new Better Together world with the amalgamation of various technologies in one solution.</p>
<p>I invite to take this journey with me!
Keep learning!</p>]]></description>
<link>http://HarvestingClouds.com/post/introducing-harvesting-clouds</link>
<pubDate>Fri, 01 Apr 2016 00:00:00 +0500</pubDate>
</item>
</channel>
</rss>
